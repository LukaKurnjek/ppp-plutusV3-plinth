{-# LANGUAGE DataKinds                  #-}
{-# LANGUAGE DeriveAnyClass             #-}
{-# LANGUAGE DeriveGeneric              #-}
{-# LANGUAGE DerivingStrategies         #-}
{-# LANGUAGE FlexibleInstances          #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE ImportQualifiedPost        #-}
{-# LANGUAGE MultiParamTypeClasses      #-}
{-# LANGUAGE NoImplicitPrelude          #-}
{-# LANGUAGE OverloadedStrings          #-}
{-# LANGUAGE PatternSynonyms            #-}
{-# LANGUAGE ScopedTypeVariables        #-}
{-# LANGUAGE Strict                     #-}
{-# LANGUAGE TemplateHaskell            #-}
{-# LANGUAGE TypeApplications           #-}
{-# LANGUAGE UndecidableInstances       #-}
{-# LANGUAGE ViewPatterns               #-}
{-# OPTIONS_GHC -fno-full-laziness #-}
{-# OPTIONS_GHC -fno-ignore-interface-pragmas #-}
{-# OPTIONS_GHC -fno-omit-interface-pragmas #-}
{-# OPTIONS_GHC -fno-spec-constr #-}
{-# OPTIONS_GHC -fno-specialise #-}
{-# OPTIONS_GHC -fno-strictness #-}
{-# OPTIONS_GHC -fno-unbox-small-strict-fields #-}
{-# OPTIONS_GHC -fno-unbox-strict-fields #-}
{-# OPTIONS_GHC -fplugin-opt PlutusTx.Plugin:target-version=1.1.0 #-}

module Week06.ExploitableSwap where

import           GHC.Generics                  (Generic)
import           PlutusLedgerApi.Common        (SerialisedScript,
                                                serialiseCompiledCode)
import           PlutusLedgerApi.Data.V3       (FromData (..))
import           PlutusLedgerApi.V3            (Datum (..), PubKeyHash,
                                                ScriptContext (..),
                                                ScriptInfo (..), TxInfo,
                                                adaSymbol, adaToken, singleton)
import           PlutusLedgerApi.V3.Contexts   (valuePaidTo)
import           PlutusTx                      (BuiltinData, CompiledCode,
                                                UnsafeFromData 
                                                  (unsafeFromBuiltinData),
                                                compile,
                                                makeIsDataSchemaIndexed)
import           PlutusTx.Blueprint            (HasBlueprintDefinition)
import           PlutusTx.Blueprint.Definition (definitionRef)
import           PlutusTx.Bool                 (Bool (..))
import           PlutusTx.Prelude              (BuiltinUnit, Eq (..), Integer,
                                                Maybe (..), check, traceError,
                                                traceIfFalse, ($), (.))

{- ------------------------------------------------------------------------------------------ -}
{- ----------------------------------------- TYPES ------------------------------------------ -}

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
  deriving stock (Generic)
  deriving anyclass (HasBlueprintDefinition)

makeIsDataSchemaIndexed ''DatumSwap [('DatumSwap, 0)]

{- ------------------------------------------------------------------------------------------ -}
{- --------------------------------------- VALIDATOR ---------------------------------------- -}

{-# INLINEABLE exploitableSwapVal #-}
exploitableSwapVal :: ScriptContext -> Bool
exploitableSwapVal ctx = traceIfFalse "Hey! You have to pay the owner!" 
                           outputToBeneficiary
 where
  info :: TxInfo
  info = scriptContextTxInfo ctx

  dat :: DatumSwap
  dat = case scriptContextScriptInfo ctx of
    SpendingScript _txRef (Just datum) -> 
      case (fromBuiltinData @DatumSwap . getDatum) datum of
        Just d  -> d
        Nothing -> traceError "Expected correctly shaped datum"
    _ -> traceError "Expected SpendingScript with datum"

  outputToBeneficiary :: Bool
  outputToBeneficiary = valuePaidTo info (beneficiary dat) == 
                          singleton adaSymbol adaToken (price dat)

{- ------------------------------------------------------------------------------------------ -}
{- ---------------------------------------- HELPERS ----------------------------------------- -}

compiledVal :: CompiledCode (BuiltinData -> BuiltinUnit)
compiledVal = $$(compile [||wrappedVal||])
 where
  wrappedVal :: BuiltinData -> BuiltinUnit
  wrappedVal ctx = PlutusTx.Prelude.check $ 
                     exploitableSwapVal (unsafeFromBuiltinData ctx)

serializedExploitableSwapVal :: SerialisedScript
serializedExploitableSwapVal = serialiseCompiledCode compiledVal
